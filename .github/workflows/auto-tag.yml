name: Auto tag on main (conventional commits)

on:
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-tag:
    if: ${{ github.actor != 'github-actions[bot]' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Determine next version
        id: bump
        run: |
          set -euo pipefail
          current_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [[ -z "$current_tag" ]]; then
            current_version=$(cat VERSION 2>/dev/null || echo "0.1.0")
          else
            # Support old tags prefixed with 'v' while moving forward without it
            current_version=${current_tag#v}
          fi
          echo "Current: $current_version"
          IFS='.' read -r major minor patch <<< "$current_version"
          commits_range="${current_tag}..HEAD"
          if [[ -z "$current_tag" ]]; then commits_range="HEAD"; fi
          commits=$(git log --pretty='%s%n%b' $commits_range)
          bump="none"
          if echo "$commits" | grep -Eqi 'BREAKING CHANGE|!:'; then bump="major"; fi
          if [[ "$bump" == "none" ]] && echo "$commits" | grep -Eiq '^feat\(|^feat:'; then bump="minor"; fi
          if [[ "$bump" == "none" ]] && echo "$commits" | grep -Eiq '^fix\(|^fix:'; then bump="patch"; fi
          case "$bump" in
            major) major=$((major+1)); minor=0; patch=0;;
            minor) minor=$((minor+1)); patch=0;;
            patch) patch=$((patch+1));;
            none) echo "No conventional commits found; skipping bump."; echo "skip=true" >> "$GITHUB_OUTPUT"; exit 0;;
          esac
          next_version="${major}.${minor}.${patch}"
          echo "Next: $next_version (bump=$bump)"
          echo "next=$next_version" >> "$GITHUB_OUTPUT"
          echo "skip=false" >> "$GITHUB_OUTPUT"

      - name: Update VERSION
        if: ${{ steps.bump.outputs.skip != 'true' }}
        id: version
        run: |
          set -euo pipefail
          next="${{ steps.bump.outputs.next }}"
          echo "$next" > VERSION
          if git diff --quiet --exit-code VERSION; then
            echo "VERSION unchanged; no commit"
            echo "version_changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "version_changed=true" >> "$GITHUB_OUTPUT"

      - name: Open version bump PR
        if: ${{ steps.bump.outputs.skip != 'true' && steps.version.outputs.version_changed == 'true' }}
        uses: peter-evans/create-pull-request@v6
        with:
          title: "chore(release): bump version to ${{ steps.bump.outputs.next }}"
          commit-message: "chore(release): bump version to ${{ steps.bump.outputs.next }}"
          branch: "chore/version-bump-${{ steps.bump.outputs.next }}"
          base: "main"
          body: "Automated version bump."
          add-paths: VERSION
          delete-branch: true
          labels: automated, release

      - name: Create and push tag
        if: ${{ steps.bump.outputs.skip != 'true' && steps.version.outputs.version_changed != 'true' }}
        id: push_tag
        run: |
          set -euo pipefail
          echo "tag_created=false" >> "$GITHUB_OUTPUT"
          echo "tag_name=" >> "$GITHUB_OUTPUT"
          next="${{ steps.bump.outputs.next }}"
          tag="${next}"
          if git rev-parse -q --verify "refs/tags/$tag" >/dev/null; then
            echo "Tag $tag already exists; skipping"; exit 0
          fi
          git tag -a "$tag" -m "Release $tag"
          git push origin "$tag"
          echo "tag_created=true" >> "$GITHUB_OUTPUT"
          echo "tag_name=$tag" >> "$GITHUB_OUTPUT"

      - name: Move production to new tag
        if: ${{ steps.push_tag.outputs.tag_created == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ steps.push_tag.outputs.tag_name }}"
          tag_commit="$(git rev-parse "refs/tags/${tag}^{commit}")"
          git fetch origin production || true
          if git rev-parse -q --verify origin/production >/dev/null; then
            git checkout -B production origin/production
          else
            git checkout -b production "$tag_commit"
          fi
          git merge --ff-only "$tag_commit"
          git push origin production
          echo "production branch updated to tag ${tag}"
