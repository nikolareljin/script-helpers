#!/usr/bin/env bash
# help.sh - Utilities for extracting and displaying script header documentation.
# Provides functions to parse and render help/usage information from standardized
# header comments in shell scripts. Supports multi-line fields and consistent output
# for script name, description, usage, parameters, examples
# and more.
set -euo pipefail

# Shared logic: extract script metadata from header comments into an associative array
get_script_metadata() {
  local script_file="$1"
  local -n _meta="$2"
  local line key current_field="" param_lines="" last_multiline_field=""
  declare -A map=(
    [name]="^# SCRIPT:[[:space:]]*(.*)"
    [description]="^# DESCRIPTION:[[:space:]]*(.*)"
    [author]="^# AUTHOR:[[:space:]]*(.*)"
    [created]="^# CREATED:[[:space:]]*(.*)"
    [version]="^# VERSION:[[:space:]]*(.*)"
    [usage]="^# USAGE:[[:space:]]*(.*)"
    [parameters]="^# PARAMETERS:[[:space:]]*(.*)"
    [example]="^# EXAMPLE:[[:space:]]*(.*)"
    [exit_codes]="^# EXIT_CODES:[[:space:]]*(.*)"
    show_usage "$script"
    [date]="^# DATE:[[:space:]]*(.*)"
    [creator]="^# CREATOR:[[:space:]]*(.*)"
  )
  # Fields that can be multi-line
  local -A multiline_fields=([parameters]=1 [usage]=1 [example]=1 [exit_codes]=1)
  for k in "${!map[@]}"; do _meta[$k]=""; done
  while IFS= read -r line || [[ -n "$line" ]]; do
    local matched=0
    for key in "${!map[@]}"; do
      if [[ $line =~ ${map[$key]} ]]; then
        matched=1
        current_field=""
        if [[ -n "${multiline_fields[$key]}" ]]; then
          _meta[$key]="${BASH_REMATCH[1]}"
          current_field="$key"
          last_multiline_field="$key"
        else
          _meta[$key]="${BASH_REMATCH[1]}"
        fi
        break
      fi
    done
    if (( ! matched )); then
    show_usage "$script_file"
      # If inside a multiline field, accumulate lines
      if [[ -n "$current_field" ]]; then
        if [[ $line =~ ^#( |\t)(.*) ]]; then
          # Continuation line (starts with # and space/tab)
          _meta[$current_field]+=$'\n'"${BASH_REMATCH[2]}"
        elif [[ $line =~ ^# ]]; then
          # New header, stop accumulating
          current_field=""
        fi
      fi
    fi
    # For param_lines (indented lines under PARAMETERS)
    if [[ $line =~ ^#\ +(.+) ]] && [[ $line != '# PARAMETERS:'* ]]; then
      param_lines+="${BASH_REMATCH[1]}

    fi

  done
}

show_usage() {
    fi
  done < "$script_file"
  _meta[param_lines]="${param_lines%\n}"
}
  local script_name; script_name="$(basename "${1:-$0}")"
    show_usage "$script_file"
  cat << EOF
Usage: $script_name [OPTIONS]

Common Options:
  -h, --help     Show this help message
  #!/usr/bin/env bash
  # help.sh - Utilities for extracting and displaying script header documentation.
  #
  # Provides functions to parse and render help/usage information from standardized
  # header comments in shell scripts. Supports multi-line fields and consistent output
  # for script name, description, usage, parameters, examples, and more.
  -d, --debug    Enable debug output

Environment Variables:
  DEBUG=true     Enable debug logging

EOF
}

parse_common_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h|--help) show_usage "$0"; exit 0;;
      -v|--verbose) export VERBOSE=true;;
      -d|--debug) export DEBUG=true;;
      *) break;;
    esac
    shift
  done
}
